<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
</body>
<script>
	// 构造函数
	/*function Fn(name,age){
		this.name = name;
		this.age = age;
		this.sayname = function(){
			return this.name +","+this.age;
		}
		this.toString = function(){
			alert("abcd");
		}
	}
	var o = new Fn("manman","20");
	Fn.prototype.in = function(){
		alert(this.name);
	}
	var a = new Fn("吴蔓","20");
	o.in();

	// 构造函数+原型模式
	function person(name){
		this.name = name;
		this.friend = ["国亚鑫","国亚❤","国瘦子","国胖子"];
	}
	// 原型模式 方法和属性共享 不安全
	// 原型上放方法
	// 构造函数里面放属性
	person.prototype.sayname=function(){
		alert(this.name);
		alert(this.friend);
	}
	var per1 = new person("吴蔓");*/

	// 对象和字符串之间的转化关系
	/*var obj={
		name:"wuman",
		age:20,
	}
	// JSON.stringify(对象名) 对象的序列化 把对象转化为字符串
	// JOSN.parse(字符串) 对象的反序列化 把字符串转化为对象
	console.log(JSON.stringify(obj));
	var str = JSON.stringify(obj);
	console.log(JSON.parse(str));*/

	// 构造函数模式
	/*function text(){
		this.name = "wuman";
	}
	 // new 的方式创建了一个对象
	var o = new text();
	console.log(o.name);*/

	function Fn(name,age){
		this.name = name;
		this.age = age;
		// 没有创建函数的过程，没有return返回值，this在调用的时候指向新对象
		this.sayname = function(){
			alert(this.name);
		}
	}
	var p1 = new Fn("wuman",18);
	console.log(p1);
</script>
</html>